<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Compositionality Interactive — Page 5</title>
  <link rel="stylesheet" href="assets/style.css" />
</head>

<body data-page="5" data-prev="page4.html" data-next="index.html">
  <div class="app">
    <div class="top">
      <h1>Now you try it</h1>
      <p>
        Use functional primitives to build a solution that meets the goal. Drag a primitive + (if needed) a function.
.
      </p>
    </div>

    <div class="main page3-grid">
      <div class="page3-spacer" aria-hidden="true"></div>

      <!-- Center: hero workspace (IDENTICAL STRUCTURE TO PAGE 3) -->
      <section class="panel page3-hero" aria-label="Interactive workspace">
        <!-- (kept for structure, hidden by CSS on page 3) -->
        <div class="panel-header">
          <div class="title">Workspace</div>
          <div class="pill">Build a pipeline</div>
        </div>

        <!-- PANEL BODY: interactive area ONLY -->
        <div class="panel-body">
        <div class="workspace page3-workspace" id="workspace" aria-label="Workspace surface">

          <!-- NEW: Challenge text (inside workspace, above nums) -->
          <div class="page5-challenge" id="challengeBox" aria-label="Challenge">
            <div class="page5-challenge-top">
            <button class="ch-nav" id="chPrev" aria-label="Previous challenge" title="Previous challenge">‹</button>

            <div class="page5-challenge-center">
              <div class="page5-challenge-title" id="challengeTitle">Challenge 1</div>
              <div class="page5-challenge-meta" id="challengeMeta">Requires: …</div>
            </div>

            <button class="ch-nav" id="chNext" aria-label="Next challenge" title="Next challenge">›</button>
          </div>
            <div class="page5-challenge-desc" id="challengeDesc">…</div>
          </div>

          <!-- Input slot (nums) -->
          <div class="ws-row">
            <div class="slot locked page3-static" id="staticNums">
              <div class="slot-label">Input</div>
              <div class="slot-body">
                <span id="numsDecl">nums = [1, 2, 3, 4, 5, 6]</span>
              </div>
            </div>
          </div>

          <!-- NEW: Ordered pipeline slots (rendered by JS) -->
          <div class="ws-row">
            <div class="page5-pipeline" id="pipelineSlots"></div>
          </div>

        </div>
 
        </div>

        <!-- PANEL FOOTER: terminal is OUTSIDE panel-body (IDENTICAL TO PAGE 3) -->
        <div class="panel-footer page3-terminal">
          <div class="terminal" aria-label="Python preview and output">
            <div class="term-title">
              <div class="label">Python (preview & output)</div>
              <button id="runBtn" class="term-run" disabled aria-disabled="true">Run</button>
            </div>

            <pre id="preview" class="term-typing" aria-live="polite">"# Drag a primitive + (if needed) a function"</pre>
            <div class="term-sep"></div>
            <pre id="result" class="muted term-typing">Output:
—</pre>
            <pre id="hint" class="muted" style="margin-top:10px; display:none;"></pre>
          </div>
        </div>
      </section>

      <!-- Right: toolbox (IDENTICAL TO PAGE 3) -->
      <section class="panel page3-bank" aria-label="Toolbox">
        <div class="panel-header">
          <div class="title">Toolbox</div>
          <div class="pill">Drag items</div>
        </div>

       <div class="panel-body">
          <div id="bankOrdered"></div>
          <div class="hint" id="rightHint" style="margin-top:12px;"></div>
        </div>
 
      </section>
    </div>

    <!-- Bottom bar (IDENTICAL TO PAGE 3) -->
    <div class="bottom">
      <div class="btnrow">
        <button id="backBtn">◀ Back</button>
        <button id="resetBtn" class="btn-primary">Reset</button>
      </div>
      <div class="btnrow">
        <!-- Page 5 ends, but keep the same Next button for styling parity -->
        <button id="nextBtn" class="btn-next">Next ▶</button>
      </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>
  </div>

  <script src="assets/nav.js"></script>
  <script>
    // =========================
    // Page 5 — Guided challenges (Page 3 terminal + typing behavior)
    // =========================

    // --- DOM ---
    const workspaceEl = document.getElementById("workspace");
    const pipelineSlotsEl = document.getElementById("pipelineSlots");
    const bankOrderedEl = document.getElementById("bankOrdered");

    const challengeTitleEl = document.getElementById("challengeTitle");
    const challengeMetaEl  = document.getElementById("challengeMeta");
    const challengeDescEl  = document.getElementById("challengeDesc");
    const numsDeclEl       = document.getElementById("numsDecl");

    const previewEl = document.getElementById("preview");
    const resultEl  = document.getElementById("result");
    const hintEl    = document.getElementById("hint");

    const runBtn = document.getElementById("runBtn");
    const resetBtn = document.getElementById("resetBtn");

    const chPrevBtn = document.getElementById("chPrev");
    const chNextBtn = document.getElementById("chNext");

    const PREVIEW_PROMPT = "# Complete the steps above, then press Run";
    previewEl.textContent = PREVIEW_PROMPT;

    // --- Functions (only those needed across challenges; still “guided”) ---
    const FUNCTIONS = {
      // predicates
      is_even: { kind: "predicate", label: "is_even", apply: (x) => x % 2 === 0 },
      is_positive: { kind: "predicate", label: "is_positive", apply: (x) => x > 0 },
      greater_than_2: { kind: "predicate", label: "greater_than_2", apply: (x) => x > 2 },

      // transforms
      square: { kind: "transform", label: "square", apply: (x) => x * x },
      double: { kind: "transform", label: "double", apply: (x) => x * 2 },
      negate: { kind: "transform", label: "negate", apply: (x) => -x },
    };

    // --- Primitives ---
    const PRIMS = {
      filter: { label: "filter", needs: "predicate" },
      map:    { label: "map",    needs: "transform" },
      sum:    { label: "sum",    needs: null },
    };

    // --- Challenges (increasing complexity) ---
    // 1) map
    // 2) map + sum
    // 3) filter + map + sum (different from earlier example: positives + square + sum)
    const CHALLENGES = [
      {
        title: "Challenge 1",
        desc: "Square every value in nums. Your output should be a new list.",
        nums: [1, 2, 3, 4],
        steps: [
          { type: "primitive", id: "map" },
          { type: "fn", kind: "transform", id: "square" },
        ],
        preview: (numsTxt) => [
          `nums = ${numsTxt}`,
          ``,
          `def square(x): return x * x`,
          `result = list(map(square, nums))`,
          `print(result)`
        ].join("\n"),
        eval: (nums) => nums.map(FUNCTIONS.square.apply)
      },
      {
        title: "Challenge 2",
        desc: "Double each value, then sum the results into a single total.",
        nums: [2, 5, 7],
        steps: [
          { type: "primitive", id: "map" },
          { type: "fn", kind: "transform", id: "double" },
          { type: "primitive", id: "sum" },
        ],
        preview: (numsTxt) => [
          `nums = ${numsTxt}`,
          ``,
          `def double(x): return x * 2`,
          `total = sum(map(double, nums))`,
          `print(total)`
        ].join("\n"),
        eval: (nums) => nums.map(FUNCTIONS.double.apply).reduce((a,b)=>a+b, 0)
      },
      {
        title: "Challenge 3",
        desc: "Keep only the positive values, square them, then sum the squares.",
        nums: [-3, -1, 0, 2, 4],
        steps: [
          { type: "primitive", id: "filter" },
          { type: "fn", kind: "predicate", id: "is_positive" },
          { type: "primitive", id: "map" },
          { type: "fn", kind: "transform", id: "square" },
          { type: "primitive", id: "sum" },
        ],
        preview: (numsTxt) => [
          `nums = ${numsTxt}`,
          ``,
          `def is_positive(x): return x > 0`,
          `def square(x): return x * x`,
          `total = sum(map(square, filter(is_positive, nums)))`,
          `print(total)`
        ].join("\n"),
        eval: (nums) => nums
          .filter(FUNCTIONS.is_positive.apply)
          .map(FUNCTIONS.square.apply)
          .reduce((a,b)=>a+b, 0)
      }
    ];

    // --- State ---
    let challengeIndex = 0;
    let filled = []; // array of {stepIndex, type, id} or null

    // --- Terminal typing (same approach as Page 3) ---
    let typingLock = false;
    let pendingPreview = null;
    let lastPreviewText = "";
    let ranOnce = false;
    let previewTypedForState = false;
    let lastReadySignature = "";


    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({
        "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
      }[c]));
    }

    function setTypingContent(el, text){
      el.innerHTML = `${escapeHtml(text)}<span class="term-cursor" aria-hidden="true"></span>`;
    }

    function setTypingContentNoCursor(el, text){
      el.textContent = String(text ?? "");
    }

    function updateChallengeNav(){
      if (!chPrevBtn || !chNextBtn) return;
      chPrevBtn.disabled = (challengeIndex === 0);
      chNextBtn.disabled = (challengeIndex === CHALLENGES.length - 1);
    }


    async function typeText(el, fullText, opts = {}){
      const speed = typeof opts.speed === "number" ? opts.speed : 18; // slowed default
      const startBlank = opts.startBlank ?? true;

      typingLock = true;
      updateRunButton();

      const text = String(fullText ?? "");
      let i = 0;

      if (startBlank) setTypingContent(el, "");

      while (i < text.length){
        const step = Math.min(2, text.length - i); // slightly smaller chunking
        i += step;
        setTypingContent(el, text.slice(0, i));
        await new Promise(r => setTimeout(r, speed));
      }

      typingLock = false;
      updateRunButton();
    }

    function queuePreviewTyping(newText){
      if (newText === lastPreviewText) return;
      lastPreviewText = newText;

      if (typingLock){
        pendingPreview = newText;
        return;
      }

      (async ()=>{
        await typeText(previewEl, newText, { speed: 18, startBlank: true });
        if (pendingPreview && pendingPreview !== newText){
          const next = pendingPreview;
          pendingPreview = null;
          queuePreviewTyping(next);
        } else {
          pendingPreview = null;
        }
      })();
    }

    // --- Workspace UI helpers ---
    function clearStatus(){
      workspaceEl.classList.remove("good","warn","bad");
      hintEl.style.display = "none";
      hintEl.textContent = "";
    }

    function setStatus(kind, msg){
      workspaceEl.classList.remove("good","warn","bad");
      workspaceEl.classList.add(kind);
      hintEl.style.display = "block";
      hintEl.textContent = msg;
    }

    function numsText(nums){
      return `[${nums.join(", ")}]`;
    }

    function formatOut(out){
      if (Array.isArray(out)) return `[${out.join(", ")}]`;
      return String(out);
    }

    // --- Rendering ---
    function renderChallenge(){
      const ch = CHALLENGES[challengeIndex];

      // header + meta
      challengeTitleEl.textContent = ch.title;
      challengeDescEl.textContent = ch.desc;

      // counts
      const primCount = ch.steps.filter(s => s.type === "primitive").length;
      const fnCount   = ch.steps.filter(s => s.type === "fn").length;
      challengeMetaEl.textContent = `Requires: ${primCount} primitive${primCount===1?"":"s"}, ${fnCount} function${fnCount===1?"":"s"}`;

      // input nums
      numsDeclEl.textContent = `nums = ${numsText(ch.nums)}`;

      // reset filled steps
      filled = ch.steps.map(()=>null);
      ranOnce = false;

      // render pipeline slots
      pipelineSlotsEl.innerHTML = "";
      ch.steps.forEach((step, i) => {
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.dataset.stepIndex = String(i);

        const label = document.createElement("div");
        label.className = "slot-label";

        if (step.type === "primitive"){
          label.textContent = `Step ${i+1}: Primitive`;
        } else {
          label.textContent = `Step ${i+1}: ${step.kind === "predicate" ? "Predicate" : "Transform"}`;
        }

        const body = document.createElement("div");
        body.className = "slot-body";
        body.innerHTML = `<span class="placeholder">Drop ${step.type === "primitive" ? "a primitive" : "a " + step.kind} here</span>`;

        slot.appendChild(label);
        slot.appendChild(body);

        enableSlotDnD(slot, step);
        pipelineSlotsEl.appendChild(slot);
      });

      // render ordered toolbox items (guided)
      renderFullBank(ch);

      updateChallengeNav();

      // terminal initial prompt
      clearStatus();
      resultEl.textContent = "Output:\n—";
      previewEl.textContent = "# Complete the steps above, then press Run";
      updateRunButton();
    }

    function renderFullBank(){
      bankOrderedEl.innerHTML = "";

      // Primitives
      const primTitle = document.createElement("div");
      primTitle.className = "group-title";
      primTitle.textContent = "Primitives";
      bankOrderedEl.appendChild(primTitle);

      ["filter", "map", "sum"].forEach((pid) => {
        const card = document.createElement("div");
        card.className = "draggable";
        card.setAttribute("draggable", "true");
        card.dataset.type = "primitive";
        card.dataset.id = pid;
        // no stepIndex now — user chooses

        const label = pid === "filter" ? "filter( predicate, data )"
                  : pid === "map"    ? "map( transform, data )"
                  :                   "sum( data )";
        card.innerHTML = `<span>${label}</span>`;
        attachDraggable(card);
        bankOrderedEl.appendChild(card);
      });

      const spacer1 = document.createElement("div");
      spacer1.style.height = "14px";
      bankOrderedEl.appendChild(spacer1);

      // Functions
      const fnTitle = document.createElement("div");
      fnTitle.className = "group-title";
      fnTitle.textContent = "Functions";
      bankOrderedEl.appendChild(fnTitle);

      const predHead = document.createElement("div");
      predHead.className = "bank-subhead";
      predHead.textContent = "Predicates (✔/✖)";
      bankOrderedEl.appendChild(predHead);

      const predicates = ["is_even", "is_positive", "greater_than_2"].filter(id => FUNCTIONS[id]);
      predicates.forEach((fid) => {
        const card = document.createElement("div");
        card.className = "draggable";
        card.setAttribute("draggable", "true");
        card.dataset.type = "fn";
        card.dataset.kind = "predicate";
        card.dataset.id = fid;
        card.innerHTML = `<span>${fid}(x)</span>`;
        attachDraggable(card);
        bankOrderedEl.appendChild(card);
      });

      const spacer2 = document.createElement("div");
      spacer2.style.height = "14px";
      bankOrderedEl.appendChild(spacer2);

      const transHead = document.createElement("div");
      transHead.className = "bank-subhead";
      transHead.textContent = "Transforms (→)";
      bankOrderedEl.appendChild(transHead);

      const transforms = ["square", "double", "negate"].filter(id => FUNCTIONS[id]);
      transforms.forEach((fid) => {
        const card = document.createElement("div");
        card.className = "draggable";
        card.setAttribute("draggable", "true");
        card.dataset.type = "fn";
        card.dataset.kind = "transform";
        card.dataset.id = fid;
        card.innerHTML = `<span>${fid}(x)</span>`;
        attachDraggable(card);
        bankOrderedEl.appendChild(card);
      });

      // Tip
      const note = document.createElement("div");
      note.className = "small";
      note.style.marginTop = "10px";
      note.style.color = "rgba(11,18,32,0.55)";
      note.textContent = "Tip: Drag items into Step slots in order. The challenge tells you how many primitives and functions you need.";
      bankOrderedEl.appendChild(note);
    }

    function renderPreview(){
      const ch = CHALLENGES[challengeIndex];

      // Only type when the whole pipeline is correct
      if (!isRunnable()){
        previewTypedForState = false;
        lastReadySignature = "";
        previewEl.textContent = PREVIEW_PROMPT;  // <- do not change preview at all
        resultEl.textContent = "Output:\n—";
        updateRunButton();
        return;
      }

      // Runnable: type full program (including nums) once per completed config
      clearStatus();
      const code = ch.preview(numsText(ch.nums));  // should include nums line
      const sig = readySignature();

      if (!previewTypedForState || sig !== lastReadySignature){
        previewTypedForState = true;
        lastReadySignature = sig;
        queuePreviewTyping(code);
      } else {
        previewEl.textContent = code;
      }

      resultEl.textContent = "Output:\n—";
      workspaceEl.classList.add("good");
      updateRunButton();
    }

 

    function readySignature(){
      return filled.map(x => x ? `${x.type}:${x.id}` : "_").join("|");
    }


    function updateRunButton(){
      const ok = isRunnable();
      runBtn.disabled = !ok;
      runBtn.setAttribute("aria-disabled", String(runBtn.disabled));
      runBtn.classList.toggle("is-enabled", ok);
    }

    async function runChallenge(){
      if (!isRunnable()) return;

      // Freeze preview (remove cursor) after Run pressed
      setTypingContentNoCursor(previewEl, lastPreviewText || previewEl.textContent);

      clearStatus();

      const ch = CHALLENGES[challengeIndex];
      let out;
      try {
        out = ch.eval(ch.nums.slice());
      } catch {
        setStatus("bad", "Something went wrong evaluating this pipeline.");
        await typeText(resultEl, "Output:\n—", { speed: 14, startBlank: true });
        return;
      }

      ranOnce = true;
      const outputText = `Output:\n${formatOut(out)}`;
      await typeText(resultEl, outputText, { speed: 14, startBlank: true });

      workspaceEl.classList.add("good");

      // advance hint
      if (challengeIndex < CHALLENGES.length - 1){
        setStatus("good", "Nice. Use Reset to try again, or move to the next challenge.");
      } else {
        setStatus("good", "All challenges complete.");
      }
    }

    function resetCurrent(){
      renderChallenge();
    }

    // --- Drag/drop ---
    function attachDraggable(el){
      el.addEventListener("dragstart", (e)=>{
        el.classList.add("dragging");
        const payload = {
          type: el.dataset.type,
          id: el.dataset.id,
          kind: el.dataset.kind || null
        };
        e.dataTransfer.setData("text/plain", JSON.stringify(payload));
        e.dataTransfer.effectAllowed = "move";
      });
      el.addEventListener("dragend", ()=>el.classList.remove("dragging"));
    }

    chPrevBtn.addEventListener("click", () => {
      if (challengeIndex <= 0) return;
      challengeIndex--;
      renderChallenge();
    });

    chNextBtn.addEventListener("click", () => {
      if (challengeIndex >= CHALLENGES.length - 1) return;
      challengeIndex++;
      renderChallenge();
    });

    function enableSlotDnD(slotEl, expectedStep){
      slotEl.addEventListener("dragover", (e)=>{
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });

      slotEl.addEventListener("drop", (e)=>{
        e.preventDefault();
        const raw = e.dataTransfer.getData("text/plain");
        if (!raw) return;

        let payload;
        try { payload = JSON.parse(raw); } catch { return; }

        const idx = parseInt(slotEl.dataset.stepIndex, 10);
        const need = CHALLENGES[challengeIndex].steps[idx];

        // enforce correct order + correct item (guided Parsons)
        if (payload.type !== need.type){
          setStatus("warn", `Step ${idx+1} needs a ${need.type === "primitive" ? "primitive" : need.kind}.`);
          return;
        }

        if (payload.id !== need.id){
          setStatus("warn", `That’s not the required ${need.type} for this step.`);
          return;
        }

        // Fill slot UI
        const body = slotEl.querySelector(".slot-body");
        if (need.type === "primitive"){
          const label = need.id === "filter" ? "filter( predicate, data )"
                    : need.id === "map"    ? "map( transform, data )"
                    :                       "sum( data )";
          body.innerHTML = `<span>${escapeHtml(label)}</span>`;
        } else {
          body.innerHTML = `<span>${escapeHtml(need.id)}(x)</span><span class="tag">${escapeHtml(need.kind)}</span>`;
        }

        slotEl.classList.add("locked");

        filled[idx] = { type: payload.type, id: payload.id, kind: payload.kind || null };

        renderPreview();
      });
    }

    // --- Events ---
    runBtn.addEventListener("click", runChallenge);
    resetBtn.addEventListener("click", resetCurrent);

    // Initial load
    renderChallenge();

    // OPTIONAL: If you want “Next ▶” to cycle challenges instead of navigating
    // (leave nav.js alone if you want the regular nav behavior)
    // document.getElementById("nextBtn").addEventListener("click", () => {
    //   if (challengeIndex < CHALLENGES.length - 1){
    //     challengeIndex++;
    //     renderChallenge();
    //   }
    // });
  </script>


</body>
</html>
