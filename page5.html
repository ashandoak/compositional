<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Compositionality Interactive ‚Äî Page 5</title>
  <link rel="stylesheet" href="assets/style.css" />
</head>

<body data-page="5" data-prev="page4.html" data-next="index.html">
  <div class="app">
    <div class="top">
      <h1>Challenge exercises</h1>
        <p>
          <strong>Instructions:</strong> Build a solution using the primitives and functions provided.
          Not every function will fit every step ‚Äî pay attention to how each primitive expects to be used.
        </p>
     </div>

    <div class="main page3-grid">
      <div class="page3-spacer" aria-hidden="true"></div>

      <!-- Center: hero workspace (IDENTICAL STRUCTURE TO PAGE 3) -->
      <section class="panel page3-hero" aria-label="Interactive workspace">
        <!-- (kept for structure, hidden by CSS on page 3) -->
        <div class="panel-header">
          <div class="title">Workspace</div>
          <div class="pill">Build a pipeline</div>
        </div>

        <!-- PANEL BODY: interactive area ONLY -->
        <div class="panel-body">
        <div class="workspace page3-workspace" id="workspace" aria-label="Workspace surface">

          <!-- NEW: Challenge text (inside workspace, above nums) -->
          <div class="page5-challenge" id="challengeBox" aria-label="Challenge">
            <div class="page5-challenge-top">
            <button class="ch-nav" id="chPrev" aria-label="Previous challenge" title="Previous challenge">‚Äπ</button>

            <div class="page5-challenge-center">
              <div class="page5-challenge-title" id="challengeTitle">Challenge 1</div>
              <div class="page5-challenge-meta" id="challengeMeta">Requires: ‚Ä¶</div>
            </div>

            <button class="ch-nav" id="chNext" aria-label="Next challenge" title="Next challenge">‚Ä∫</button>
          </div>
            <div class="page5-challenge-desc" id="challengeDesc">‚Ä¶</div>
          </div>
          
        <!-- Input slot (nums) -->
          <div class="ws-row">
            <div class="slot locked page3-static" id="staticNums">
              <div class="slot-label">Input</div>
              <div class="slot-body">
                <span id="numsDecl">nums = [1, 2, 3, 4, 5, 6]</span>
              </div>
            </div>
          </div>

          <!-- NEW: Ordered pipeline slots (rendered by JS) -->
          <div class="ws-row">
            <div class="page5-pipeline" id="pipelineSlots"></div>
          </div>

          <div class="coach panel2" id="coach" role="status" aria-live="polite">
            <span class="coach-icon">‚ÑπÔ∏è</span>
            <span class="coach-text">Drag a primitive into the pipeline to begin.</span>
          </div>
        </div>
 
        </div>

        <!-- PANEL FOOTER: terminal is OUTSIDE panel-body (IDENTICAL TO PAGE 3) -->
        <div class="panel-footer page3-terminal">
          <div class="terminal" aria-label="Python preview and output">
            <div class="term-title">
              <div class="label">Python (preview & output)</div>
              <button id="runBtn" class="term-run" disabled aria-disabled="true">Run</button>
            </div>

            <pre id="preview" class="term-typing" aria-live="polite">"# Drag a primitive + (if needed) a function"</pre>
            <div class="term-sep"></div>
            <pre id="result" class="muted term-typing">Output:
‚Äî</pre>
          </div>
        </div>
        <div id="celebrate" class="celebrate" aria-hidden="true">
          <div class="celebrate-pop">
            <div class="celebrate-emoji">üéâ</div>
            <div class="celebrate-text">Challenge complete!</div>
          </div>
          <div class="confetti" aria-hidden="true"></div>
        </div>

      </section>

      <!-- Right: toolbox (IDENTICAL TO PAGE 3) -->
      <section class="panel page3-bank" aria-label="Toolbox">
        <div class="panel-header">
          <div class="title">Toolbox</div>
          <div class="pill">Drag items</div>
        </div>

       <div class="panel-body">
          <div id="bankOrdered"></div>
          <div class="hint" id="rightHint" style="margin-top:12px;"></div>
        </div>
 
      </section>
    </div>

    <!-- Bottom bar (IDENTICAL TO PAGE 3) -->
    <div class="bottom">
      <div class="btnrow">
        <button id="backBtn">‚óÄ Back</button>
        <button id="resetBtn" class="btn-primary">Reset</button>
      </div>
      <div class="btnrow">
        <!-- Page 5 ends, but keep the same Next button for styling parity -->
        <button id="nextBtn" class="btn-next">Next ‚ñ∂</button>
      </div>
    </div>
  </div>

  <script src="assets/nav.js"></script>
  <script>
    // =========================
    // Page 5 ‚Äî Guided challenges (Page 3 terminal + typing behavior)
    // =========================

    // --- DOM ---
    const workspaceEl = document.getElementById("workspace");
    const pipelineSlotsEl = document.getElementById("pipelineSlots");
    const bankOrderedEl = document.getElementById("bankOrdered");

    const challengeTitleEl = document.getElementById("challengeTitle");
    const challengeMetaEl  = document.getElementById("challengeMeta");
    const challengeDescEl  = document.getElementById("challengeDesc");
    const numsDeclEl       = document.getElementById("numsDecl");

    const previewEl = document.getElementById("preview");
    const resultEl  = document.getElementById("result");
    const runBtn = document.getElementById("runBtn");
    const resetBtn = document.getElementById("resetBtn");

    const chPrevBtn = document.getElementById("chPrev");
    const chNextBtn = document.getElementById("chNext");

    const PREVIEW_PROMPT = "# Complete the steps above, then press Run";
    previewEl.textContent = PREVIEW_PROMPT;


    // --- Functions (only those needed across challenges; still ‚Äúguided‚Äù) ---
    const FUNCTIONS = {
      // predicates
      is_even: { kind: "predicate", label: "is_even", apply: (x) => x % 2 === 0 },
      is_positive: { kind: "predicate", label: "is_positive", apply: (x) => x > 0 },
      greater_than_2: { kind: "predicate", label: "greater_than_2", apply: (x) => x > 2 },

      // transforms
      square: { kind: "transform", label: "square", apply: (x) => x * x },
      double: { kind: "transform", label: "double", apply: (x) => x * 2 },
      negate: { kind: "transform", label: "negate", apply: (x) => -x },
    };

    // --- Primitives ---
    const PRIMS = {
      sum:    { label: "sum",    needs: null },
      map:    { label: "map",    needs: "transform" },
      filter: { label: "filter", needs: "predicate" },
    };

    // --- Challenges (increasing complexity) ---
    // 1) map
    // 2) map + sum
    // 3) filter + map + sum (different from earlier example: positives + square + sum)
    const CHALLENGES = [
    {
      title: "Challenge 1",
      desc: "Square every value in the nums array and output a new list.",
      nums: [1, 2, 3, 4],
      steps: [
        { type: "primitive", id: "map" },
        { type: "fn", kind: "transform", id: "square" },
      ],
      comment: [
        "# map transforms each value independently",
        "# it produces a new list without changing nums"
      ],
      preview: (numsTxt) => [
        `nums = ${numsTxt}`,
        ``,
        `def square(x): return x * x`,
        `result = list(map(square, nums))`,
        `print(result)`
      ].join("\n"),
      eval: (nums) => nums.map(FUNCTIONS.square.apply)
    },
    {
      title: "Challenge 2",
      desc: "Double each value in the nums array, then sum the results into a single total.",
      nums: [2, 5, 7],
      steps: [
        { type: "primitive", id: "map" },
        { type: "fn", kind: "transform", id: "double" },
        { type: "primitive", id: "sum" },
      ],
      comment: [
        "# map transforms each value independently",
        "# sum reduces a list to a single value"
      ],
       preview: (numsTxt) => [
        `nums = ${numsTxt}`,
        ``,
        `def double(x): return x * 2`,
        `total = sum(map(double, nums))`,
        `print(total)`
      ].join("\n"),
      eval: (nums) => nums.map(FUNCTIONS.double.apply).reduce((a,b)=>a+b, 0)
    },
    {
      title: "Challenge 3",
      nums: [-3, -1, 0, 2, 4],
      desc: "Keep only the positive values in the nums array, then square them, and sum the squares into a single total.",
      steps: [
        { type: "primitive", id: "filter" },
        { type: "fn", kind: "predicate", id: "is_positive" },
        { type: "primitive", id: "map" },
        { type: "fn", kind: "transform", id: "square" },
        { type: "primitive", id: "sum" },
      ],
      comment: [
        "# filter keeps only values where the predicate returns True",
        "# map transforms each remaining value independently",
        "# sum reduces the final list to a single value"
      ],
       preview: (numsTxt) => [
        `nums = ${numsTxt}`,
        ``,
        `def is_positive(x): return x > 0`,
        `def square(x): return x * x`,
        `total = sum(map(square, filter(is_positive, nums)))`,
        `print(total)`
      ].join("\n"),
      eval: (nums) => nums
        .filter(FUNCTIONS.is_positive.apply)
        .map(FUNCTIONS.square.apply)
        .reduce((a,b)=>a+b, 0)
    }
  ];


    // --- State ---
    let challengeIndex = 0;
    let filled = []; // array of {stepIndex, type, id} or null

    let celebrateHideTimer = null;

    // Track completion so we can pulse the Next chevron after Challenge 1 is solved
    const completed = CHALLENGES.map(() => false);

    function updateNextChevronPulse(){
      if (!chNextBtn) return;
      const shouldPulse =
        (challengeIndex === 0) &&
        completed[0] &&
        (challengeIndex < CHALLENGES.length - 1);

      chNextBtn.classList.toggle("pulse-next", shouldPulse);
    }

    function celebrate(){
      // subtle workspace success pop
      workspaceEl.classList.add("celebrate");
      window.setTimeout(()=>workspaceEl.classList.remove("celebrate"), 700);

      // quick confetti burst (tiny DOM, removed automatically)
      const burstCount = 14;
      const rect = workspaceEl.getBoundingClientRect();

      for (let i = 0; i < burstCount; i++){
        const bit = document.createElement("span");
        bit.className = "confetti";

        // random bright-ish colors
        const hue = Math.floor(Math.random() * 360);
        bit.style.background = `hsl(${hue} 92% 58%)`;

        // random horizontal start across the workspace
        bit.style.left = `${Math.random() * Math.max(120, rect.width - 20)}px`;

        // random drift + stagger
        bit.style.animationDelay = `${Math.random() * 120}ms`;

        workspaceEl.appendChild(bit);

        // cleanup
        window.setTimeout(()=>bit.remove(), 1100);
      }
    }

    function markChallengeSolved(){
      if (completed[challengeIndex]) return; // avoid repeat triggers
      completed[challengeIndex] = true;
      updateNextChevronPulse();
    }

    // --- Terminal typing (same approach as Page 3) ---
    let typingLock = false;
    let pendingPreview = null;
    let lastPreviewText = "";
    let ranOnce = false;
    let previewTypedForState = false;
    let lastReadySignature = "";


    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({
        "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
      }[c]));
    }

    function setTypingContent(el, text){
      el.innerHTML = `${escapeHtml(text)}<span class="term-cursor" aria-hidden="true"></span>`;
    }

    function setTypingContentNoCursor(el, text){
      el.textContent = String(text ?? "");
    }

    function updateChallengeNav(){
      if (!chPrevBtn || !chNextBtn) return;
      chPrevBtn.disabled = (challengeIndex === 0);
      chNextBtn.disabled = (challengeIndex === CHALLENGES.length - 1);
    }


    async function typeText(el, fullText, opts = {}){
      const speed = typeof opts.speed === "number" ? opts.speed : 18; // slowed default
      const startBlank = opts.startBlank ?? true;

      typingLock = true;
      updateRunButton();

      const text = String(fullText ?? "");
      let i = 0;

      if (startBlank) setTypingContent(el, "");

      while (i < text.length){
        const step = Math.min(2, text.length - i); // slightly smaller chunking
        i += step;
        setTypingContent(el, text.slice(0, i));
        await new Promise(r => setTimeout(r, speed));
      }

      typingLock = false;
      updateRunButton();
    }

    function queuePreviewTyping(newText){
      if (newText === lastPreviewText) return;
      lastPreviewText = newText;

      if (typingLock){
        pendingPreview = newText;
        return;
      }

      (async ()=>{
        await typeText(previewEl, newText, { speed: 18, startBlank: true });
        if (pendingPreview && pendingPreview !== newText){
          const next = pendingPreview;
          pendingPreview = null;
          queuePreviewTyping(next);
        } else {
          pendingPreview = null;
        }
      })();
    }

    // --- Workspace UI helpers ---
    function clearStatus(){
      workspaceEl.classList.remove("good","warn","bad");
      // no terminal failure/status messaging on page 5 (use coach + slot outlines instead)
    }

    function setStatus(kind, msg){
      workspaceEl.classList.remove("good","warn","bad");
      workspaceEl.classList.add(kind);
      // Show guidance in the coach panel instead of the terminal.
      if (kind === "good") setCoach("good", msg);
      else if (kind === "warn") setCoach("warn", msg);
      else if (kind === "bad") setCoach("bad", msg);
    }

    function numsText(nums){
      return `[${nums.join(", ")}]`;
    }

    function formatOut(out){
      if (Array.isArray(out)) return `[${out.join(", ")}]`;
      return String(out);
    }

    function setCoach(state, text){
      const el = document.getElementById("coach");
      if (!el) return;

      el.classList.remove("is-good","is-warn","is-bad");
      if (state) el.classList.add(`is-${state}`);

      const t = el.querySelector(".coach-text");
      if (t) t.innerHTML = text;
    }

    function pulseDropError(slotEl, severity="bad"){
      if (!slotEl) return;
      const cls = severity === "warn" ? "drop-warn" : "drop-bad";
      slotEl.classList.remove("drop-warn","drop-bad","shake");
      void slotEl.offsetWidth;
      slotEl.classList.add(cls,"shake");
      window.clearTimeout(pulseDropError._t);
      pulseDropError._t = window.setTimeout(()=>{
        slotEl.classList.remove("shake","drop-warn","drop-bad");
      }, 900);
    }

    function primStageForIndex(ch, idx){
      let stage = 0;
      for (let i = 0; i <= idx; i++){
        if (ch.steps[i].type === "primitive") stage++;
      }
      return stage; // 1-based
    }


    function clearConnHighlights(){
      document.querySelectorAll('[class*="conn-hl-"]').forEach(el=>{
        el.className = el.className.replace(/\bconn-hl-\d+\b/g, '');
      });
    }

    function applyConnIndex(idx, root, selector){
      const scope = root || document;
      scope.querySelectorAll(selector).forEach(el=>{
        el.classList.add(`conn-hl-${idx}`);
      });
    }

   function applyConnHighlights(){
      clearConnHighlights();

      const ch = CHALLENGES[challengeIndex];

      function slotForStep(i){
        return pipelineSlotsEl.querySelector(`.slot[data-step-index="${i}"]`);
      }

      // Collect primitive step indices in order
      const primStepIdxs = [];
      for (let i = 0; i < ch.steps.length; i++){
        if (ch.steps[i].type === "primitive") primStepIdxs.push(i);
      }

      // 3 channels per primitive stage: IN, BIND, OUT
      function stageChannels(stage1Based){
        const base = (stage1Based - 1) * 3;
        return { IN: base, BIND: base + 1, OUT: base + 2 };
      }

      for (let p = 0; p < primStepIdxs.length; p++){
        const primIdx = primStepIdxs[p];
        if (!filled[primIdx]) continue;

        const stage = p + 1; // 1-based primitive stage
        const { IN, BIND, OUT } = stageChannels(stage);

        const primSlot = slotForStep(primIdx);
        if (!primSlot) continue;

        // Always highlight this primitive's `data` parameter with stage IN color
        applyConnIndex(IN, primSlot, '.conn-token[data-conn="data"]');

        // Input source:
        // - stage 1 comes from nums
        // - stage 2+ comes from previous output chip
        if (stage === 1){
          applyConnIndex(IN, numsDeclEl, '.conn-token[data-conn="data"]');
        } else {
          const prevOutChip = pipelineSlotsEl.querySelector(`.out-chip[data-stage="${stage-1}"]`);
          if (prevOutChip){
            // show that previous output feeds this stage's data:
            prevOutChip.classList.add(`conn-hl-${IN}`);
          }
        }

        // Function binding (only when fn step exists and is filled)
        const primNeed = ch.steps[primIdx];
        const needsFn = (primNeed.id === "filter" || primNeed.id === "map");
        if (needsFn){
          const fnIdx = primIdx + 1;
          if (ch.steps[fnIdx] && ch.steps[fnIdx].type === "fn" && filled[fnIdx]){
            const fnSlot = slotForStep(fnIdx);
            if (fnSlot){
              applyConnIndex(BIND, primSlot, '.conn-token[data-conn="need"]');
              applyConnIndex(BIND, fnSlot, '.conn-token[data-conn="fn"]');
            }
          }
        }

        // Output chip emphasis (stage OUT color) only when it matters:
        // if a later primitive exists AND is placed (so the output is actually used)
        const outChip = pipelineSlotsEl.querySelector(`.out-chip[data-stage="${stage}"]`);
        const hasNext = (p + 1 < primStepIdxs.length);
        const nextPlaced = hasNext && filled[primStepIdxs[p + 1]];
        if (outChip && nextPlaced){
          outChip.classList.add(`conn-hl-${OUT}`);
        }
      }
    }

    function ensureConfetti(){
      const host = document.querySelector("#celebrate .confetti");
      if (!host) return null;

      if (host.children.length) return host;

      // Create 12 confetti pieces once
      for (let i = 0; i < 12; i++){
        const piece = document.createElement("i");
        host.appendChild(piece);
      }
      return host;
    }

    function fireCelebrate(){
      const overlay = document.getElementById("celebrate");
      if (!overlay) return;

      const host = ensureConfetti();
      if (host){
        const pieces = Array.from(host.children);

        // Use your existing palette tokens
        const colors = [
          "rgba(75,123,255,0.9)",  // accent blue
          "rgba(22,165,107,0.9)",  // good green
          "rgba(209,138,0,0.9)",   // warn amber
          "rgba(140,90,255,0.9)",  // purple
          "rgba(224,59,59,0.9)"    // red
        ];

        pieces.forEach((el, idx)=>{
          const angle = (Math.PI * 2) * (idx / pieces.length);
          const r = 90 + Math.random() * 70;
          const dx = Math.cos(angle) * r;
          const dy = Math.sin(angle) * r - 40; // bias upward
          const rot = (Math.random() * 240 - 120) + "deg";

          el.style.background = colors[idx % colors.length];
          el.style.setProperty("--dx", `${dx.toFixed(1)}px`);
          el.style.setProperty("--dy", `${dy.toFixed(1)}px`);
          el.style.setProperty("--rot", rot);
        });
      }

      // Optional: pulse the workspace
      const workspace = document.querySelector(".workspace");
      if (workspace){
        workspace.classList.remove("is-success");
        void workspace.offsetWidth;
        workspace.classList.add("is-success");
        window.setTimeout(()=> workspace.classList.remove("is-success"), 700);
      }

      overlay.classList.remove("is-on");
      void overlay.offsetWidth; // restart animations
      overlay.classList.add("is-on");


      // restart animation
      overlay.classList.remove("is-on");
      void overlay.offsetWidth;
      overlay.classList.add("is-on");

      // ‚úÖ auto-hide (important)
      if (celebrateHideTimer) window.clearTimeout(celebrateHideTimer);
      celebrateHideTimer = window.setTimeout(()=>{
        overlay.classList.remove("is-on");
      }, 1200);
    }



    // --- Rendering ---
    function renderChallenge(){
      const ch = CHALLENGES[challengeIndex];

      // header + meta
      challengeTitleEl.textContent = ch.title;
      challengeDescEl.textContent = ch.desc;

      // counts
      const primCount = ch.steps.filter(s => s.type === "primitive").length;
      const fnCount   = ch.steps.filter(s => s.type === "fn").length;
      challengeMetaEl.textContent = `Requires: ${primCount} primitive${primCount===1?"":"s"}, ${fnCount} function${fnCount===1?"":"s"}`;

      // input nums
      numsDeclEl.innerHTML = `<span class="conn-token" data-conn="data">nums</span> = ${escapeHtml(numsText(ch.nums))}`;

      // reset filled steps
      filled = ch.steps.map(()=>null);
      ranOnce = false;

      // render pipeline slots
      pipelineSlotsEl.innerHTML = "";
      ch.steps.forEach((step, i) => {
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.dataset.stepIndex = String(i);

        const label = document.createElement("div");
        label.className = "slot-label";

        if (step.type === "primitive"){
          label.textContent = `Step ${i+1}: Primitive`;
        } else {
          label.textContent = `Step ${i+1}: ${step.kind === "predicate" ? "Predicate" : "Transform"}`;
        }

        const body = document.createElement("div");
        body.className = "slot-body";
        body.innerHTML = `<span class="placeholder">Drop ${step.type === "primitive" ? "a primitive" : "a " + step.kind} here</span>`;

        slot.appendChild(label);
        slot.appendChild(body);

        enableSlotDnD(slot, step);
        pipelineSlotsEl.appendChild(slot);
      });

      // render ordered toolbox items (guided)
      renderFullBank(ch);

      updateChallengeNav();
      updateNextChevronPulse();


      // terminal initial prompt
      clearStatus();
      resultEl.textContent = "Output:\n‚Äî";
      previewEl.textContent = PREVIEW_PROMPT;
      // --- reset typing state so completing the challenge always animates ---
      typingLock = false;
      pendingPreview = null;
      lastPreviewText = "";
      previewTypedForState = false;
      lastReadySignature = "";
      updateRunButton();
    }

    function renderFullBank(){
      bankOrderedEl.innerHTML = "";

      // Primitives
      const primTitle = document.createElement("div");
      primTitle.className = "group-title";
      primTitle.textContent = "Primitives";
      bankOrderedEl.appendChild(primTitle);

      ["sum", "map", "filter"].forEach((pid) => {
        const card = document.createElement("div");
        card.className = "draggable";
        card.setAttribute("draggable", "true");
        card.dataset.type = "primitive";
        card.dataset.id = pid;
        // no stepIndex now ‚Äî user chooses

        const label = pid === "filter" ? "filter( predicate, data )"
                  : pid === "map"    ? "map( transform, data )"
                  :                   "sum( data )";
        card.innerHTML = `<span>${label}</span>`;
        attachDraggable(card);
        bankOrderedEl.appendChild(card);
      });

      const spacer1 = document.createElement("div");
      spacer1.style.height = "14px";
      bankOrderedEl.appendChild(spacer1);

      // Functions
      const fnTitle = document.createElement("div");
      fnTitle.className = "group-title";
      fnTitle.textContent = "Functions";
      bankOrderedEl.appendChild(fnTitle);

      const predHead = document.createElement("div");
      predHead.className = "bank-subhead";
      predHead.textContent = "Predicates (‚úî/‚úñ)";
      bankOrderedEl.appendChild(predHead);

      const predicates = ["is_even", "is_positive", "greater_than_2"].filter(id => FUNCTIONS[id]);
      predicates.forEach((fid) => {
        const card = document.createElement("div");
        card.className = "draggable";
        card.setAttribute("draggable", "true");
        card.dataset.type = "fn";
        card.dataset.kind = "predicate";
        card.dataset.id = fid;
        card.innerHTML = `<span>${fid}(x)</span>`;
        attachDraggable(card);
        bankOrderedEl.appendChild(card);
      });

      const spacer2 = document.createElement("div");
      spacer2.style.height = "14px";
      bankOrderedEl.appendChild(spacer2);

      const transHead = document.createElement("div");
      transHead.className = "bank-subhead";
      transHead.textContent = "Transforms (‚Üí)";
      bankOrderedEl.appendChild(transHead);

      const transforms = ["square", "double", "negate"].filter(id => FUNCTIONS[id]);
      transforms.forEach((fid) => {
        const card = document.createElement("div");
        card.className = "draggable";
        card.setAttribute("draggable", "true");
        card.dataset.type = "fn";
        card.dataset.kind = "transform";
        card.dataset.id = fid;
        card.innerHTML = `<span>${fid}(x)</span>`;
        attachDraggable(card);
        bankOrderedEl.appendChild(card);
      });

      // Tip
      const note = document.createElement("div");
      note.className = "small";
      note.style.marginTop = "10px";
      note.style.color = "rgba(11,18,32,0.55)";
      note.textContent = "Tip: Drag items into Step slots in order. The challenge tells you how many primitives and functions you need.";
      bankOrderedEl.appendChild(note);
    }


   function renderPreview(){
      // Keep preview completely unchanged until the pipeline is fully correct
      if (!isRunnable()){
        previewTypedForState = false;
        lastReadySignature = "";
        pendingPreview = null;
        lastPreviewText = "";              // ensures we animate when it becomes runnable

        previewEl.textContent = PREVIEW_PROMPT;
        resultEl.textContent = "Output:\n‚Äî";
        updateRunButton();
        return;
      }

      // Runnable: type full program (includes nums) once per completed configuration
      const ch = CHALLENGES[challengeIndex];
      const code = ch.preview(numsText(ch.nums)); // your preview builder already includes nums
      const sig = readySignature();

      if (!previewTypedForState || sig !== lastReadySignature){
        previewTypedForState = true;
        lastReadySignature = sig;
        queuePreviewTyping(code);
      } else {
        previewEl.textContent = code;
      }

      resultEl.textContent = "Output:\n‚Äî";
      workspaceEl.classList.add("good");
      updateRunButton();
    }
 

 

    function readySignature(){
      return filled.map(x => x ? `${x.type}:${x.id}` : "_").join("|");
    }

    function isRunnable(){
      if (typingLock) return false;

      const ch = CHALLENGES[challengeIndex];

      // every step must be filled and must match the required item for that step
      for (let i = 0; i < ch.steps.length; i++){
        const need = ch.steps[i];
        const got = filled[i];

        if (!got) return false;
        if (got.type !== need.type) return false;
        if (got.id !== need.id) return false;

        if (need.type === "fn" && got.kind !== need.kind) return false;
      }

      return true;
    }


    function updateRunButton(){
      const ok = isRunnable();
      runBtn.disabled = !ok;
      runBtn.setAttribute("aria-disabled", String(runBtn.disabled));
      runBtn.classList.toggle("is-enabled", ok);
    }

    async function runChallenge(){
      if (!isRunnable()) return;

      // Freeze preview (remove cursor) after Run pressed
      setTypingContentNoCursor(previewEl, lastPreviewText || previewEl.textContent);

      clearStatus();

      const ch = CHALLENGES[challengeIndex];
      let out;
      try {
        out = ch.eval(ch.nums.slice());
      } catch {
        pulseDropError(workspaceEl);
        setCoach("warn", "That pipeline couldn‚Äôt be evaluated. Double-check the required steps for this challenge.");
        return;
      }

      ranOnce = true;
      const commentLines = Array.isArray(ch.comment) ? ch.comment : [];
      const commentBlock = commentLines.length ? ("\n\n" + commentLines.join("\n")) : "";

      const outputText = `Output:\n${formatOut(out)}${commentBlock}`;
      await typeText(resultEl, outputText, { speed: 14, startBlank: true });
      markChallengeSolved();
      fireCelebrate();
      workspaceEl.classList.add("good");

      // advance hint
      if (challengeIndex < CHALLENGES.length - 1){
        setStatus("good", "Nice. Use Reset to try again, or move to the next challenge.");
      } else {
        setStatus("good", "All challenges complete.");
      }
    }

    function resetCurrent(){
      renderChallenge();
    }

    // --- Drag/drop ---
    function attachDraggable(el){
      el.addEventListener("dragstart", (e)=>{
        el.classList.add("dragging");
        const payload = {
          type: el.dataset.type,
          id: el.dataset.id,
          kind: el.dataset.kind || null
        };
        e.dataTransfer.setData("text/plain", JSON.stringify(payload));
        e.dataTransfer.effectAllowed = "move";
      });
      el.addEventListener("dragend", ()=>el.classList.remove("dragging"));
    }

    chPrevBtn.addEventListener("click", () => {
      if (challengeIndex <= 0) return;
      challengeIndex--;
      renderChallenge();
    });

    chNextBtn.addEventListener("click", () => {
      if (challengeIndex >= CHALLENGES.length - 1) return;
      challengeIndex++;
      renderChallenge();
    });

    function enableSlotDnD(slotEl, expectedStep){
      slotEl.addEventListener("dragover", (e)=>{
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });

      slotEl.addEventListener("drop", (e)=>{
        e.preventDefault();
        const raw = e.dataTransfer.getData("text/plain");
        if (!raw) return;

        let payload;
        try { payload = JSON.parse(raw); } catch { return; }

        const idx = parseInt(slotEl.dataset.stepIndex, 10);
        const need = CHALLENGES[challengeIndex].steps[idx];

        // enforce correct order + correct item (guided Parsons)
        if (payload.type !== need.type){
          pulseDropError(slotEl);
          setCoach("warn", need.type === "primitive"
            ? `Step ${idx+1} needs a <strong>primitive</strong> (filter, map, sum).`
            : `Step ${idx+1} needs a <strong>${need.kind}</strong> function.`);
          return;
        }

        if (payload.id !== need.id){
          pulseDropError(slotEl);
          if (need.type === "fn"){
            const dropped = FUNCTIONS[payload.id];
            const droppedKind = dropped ? dropped.kind : "function";
            const droppedLabel = dropped ? dropped.label : payload.id;

            // Wrong kind (predicate vs transform)
            if (droppedKind !== need.kind){
              if (need.kind === "predicate"){
                setCoach("warn", `This step needs a <strong>predicate</strong> (returns True/False). You dropped <strong>${droppedLabel}</strong>, a <strong>${droppedKind}</strong>. Try <strong>is_even</strong>, <strong>is_positive</strong>, or <strong>greater_than_2</strong>.`);
              } else {
                setCoach("warn", `This step needs a <strong>transform</strong> (changes each element). You dropped <strong>${droppedLabel}</strong>, a <strong>${droppedKind}</strong>. Try <strong>square</strong>, <strong>double</strong>, or <strong>negate</strong>.`);
              }
              return;
            }

            // Correct kind, but wrong specific function for this challenge
            setCoach("warn", `This challenge expects <strong>${need.id}</strong> here (a <strong>${need.kind}</strong>). You dropped <strong>${droppedLabel}</strong>. Try <strong>${need.id}</strong>.`);
          } else {
            setCoach("warn", `This step needs <strong>${need.id}</strong>.`);
          }
          return;
        }

        // Fill slot UI
        const body = slotEl.querySelector(".slot-body");

        if (need.type === "primitive"){
          const ch = CHALLENGES[challengeIndex];
          const stage = primStageForIndex(ch, idx); // 1-based primitive stage

          const label =
            need.id === "filter" ? `filter( <span class="conn-token" data-conn="need">predicate</span>, <span class="conn-token" data-conn="data">data</span> )`
          : need.id === "map"    ? `map( <span class="conn-token" data-conn="need">transform</span>, <span class="conn-token" data-conn="data">data</span> )`
          :                       `sum( <span class="conn-token" data-conn="data">data</span> )`;

          // IMPORTANT: two sibling spans, no newline between them (keeps flex sane)
          body.innerHTML =
            `<span>${label}</span>` +
            `<span class="out-chip conn-token" data-conn="out" data-stage="${stage}">output${stage}</span>`;
        } else {
          body.innerHTML =
            `<span><span class="conn-token" data-conn="fn">${escapeHtml(need.id)}</span>(x)</span>`;
        }



        slotEl.classList.add("locked");

        filled[idx] = { type: payload.type, id: payload.id, kind: payload.kind || null };

        // Positive feedback (coach)
        const totalSteps = CHALLENGES[challengeIndex].steps.length;
        const isLast = idx === totalSteps - 1;

        if (payload.type === "primitive"){
          if (payload.id === "map"){
            setCoach("good", `Nice ‚Äî <strong>map</strong> placed. Now drop a <strong>transform</strong> into the next slot.`);
          } else if (payload.id === "filter"){
            setCoach("good", `Nice ‚Äî <strong>filter</strong> placed. Now drop a <strong>predicate</strong> into the next slot.`);
          } else if (payload.id === "sum"){
            setCoach("good", isLast
              ? `Nice ‚Äî <strong>sum</strong> placed. Run the code in the terminal.`
              : `Nice ‚Äî <strong>sum</strong> placed. Continue to the next step.`);
          } else {
            setCoach("good", `Nice ‚Äî <strong>${payload.id}</strong> placed.`);
          }
        } else if (payload.type === "fn"){
          const dropped = FUNCTIONS[payload.id];
          const droppedLabel = dropped ? dropped.label : payload.id;
          setCoach("good", isLast
            ? `Great ‚Äî <strong>${droppedLabel}</strong> fits here. Run the code in the terminal.`
            : `Great ‚Äî <strong>${droppedLabel}</strong> fits here. Continue to the next step.`);
        }


        renderPreview();
        applyConnHighlights();
      });
    }

    // --- Events ---
    runBtn.addEventListener("click", runChallenge);
    resetBtn.addEventListener("click", resetCurrent);

    // Initial load
    renderChallenge();

    // OPTIONAL: If you want ‚ÄúNext ‚ñ∂‚Äù to cycle challenges instead of navigating
    // (leave nav.js alone if you want the regular nav behavior)
    // document.getElementById("nextBtn").addEventListener("click", () => {
    //   if (challengeIndex < CHALLENGES.length - 1){
    //     challengeIndex++;
    //     renderChallenge();
    //   }
    // });
  </script>


</body>
</html>