<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Compositionality Interactive — Page 3</title>
  <link rel="stylesheet" href="assets/style.css" />
</head>

<body data-page="3" data-prev="page2.html" data-next="page4.html">
  <div class="app">
    <div class="top">
      <h1>Exploring functional composition</h1>
        <p>
          <strong>Instructions:</strong> Experiment by dragging primitives and functions into the workspace.
          Each primitive performs one focused task, defined by the pedicate or transform function, and together they form a complete program.
          Try different combinations and observe how the data changes at each step.
        </p>
    </div>

    <div class="main page3-grid">
      <div class="page3-spacer" aria-hidden="true"></div>

      <!-- Center: hero workspace -->
      <section class="panel page3-hero" aria-label="Interactive workspace">
        <div class="panel-header">
          <div class="title">Workspace</div>
          <div class="pill">Build a pipeline</div>
        </div>

        <!-- PANEL BODY: interactive area ONLY -->
        <div class="panel-body">
          <div class="workspace page3-workspace" id="workspace" aria-label="Workspace surface">
            <!-- Static input array (NEW) -->
            <div class="ws-row">
              <div class="slot locked page3-static" id="staticNums">
                <div class="slot-label">Input</div>
                <div class="slot-body">
                  <span><span class="conn-token" data-conn="data">nums</span> = [1, 2, 3, 4, 5, 6]</span>                
                </div>
              </div>
            </div>

            <div class="ws-row">
              <div class="slot" id="slotPrimitive">
                <div class="slot-label">Primitive</div>
                <div class="slot-body">
                  <span class="placeholder">Drop a primitive here</span>
                </div>
              </div>

              <div class="slot" id="slotFunction">
                <div class="slot-label">Function (optional)</div>
                <div class="slot-body">
                  <span class="placeholder">Drop a predicate/transform here (if needed)</span>
                </div>
              </div>
            </div>
            <div class="coach panel2" id="coach" role="status" aria-live="polite">
              <span class="coach-icon">ℹ️</span>
              <span class="coach-text">Drag a primitive into the pipeline to begin.</span>
            </div>
          </div>
        </div>



        <!-- PANEL FOOTER: terminal is OUTSIDE panel-body -->
        <div class="panel-footer page3-terminal">
          <div class="terminal" aria-label="Python preview and output">
            <div class="term-title">
              <div class="label">Python (preview &amp; output)</div>

              <!-- REPLACE "simulated" tag with RUN button (NEW) -->
              <button id="runBtn" class="term-run" disabled aria-disabled="true">Run</button>
            </div>

            <!-- Typed preview (NEW: typing animation + cursor) -->
            <pre id="preview" class="term-typing" aria-live="polite"></pre>
            <div class="term-sep"></div>

            <!-- Output only types when Run pressed -->
            <pre id="result" class="muted term-typing">Output:
—</pre>
          </div>
        </div>
      </section>

      <!-- Right: toolbox -->
      <section class="panel page3-bank" aria-label="Toolbox">
        <div class="panel-header">
          <div class="title">Toolbox</div>
          <div class="pill">Drag items</div>
        </div>

        <div class="panel-body">
          <!-- Arrays section REMOVED -->

          <div class="group-title">Primitives</div>

          <div class="draggable" draggable="true" data-type="primitive" data-id="sum">
            <span>sum( data )</span>
          </div>         
          <div class="draggable" draggable="true" data-type="primitive" data-id="map">
            <span>map( transform, data )</span>
          </div>
          <div class="draggable" draggable="true" data-type="primitive" data-id="filter">
            <span>filter( predicate, data )</span>
          </div>

          <div style="height:14px;"></div>

          <div class="group-title">Functions</div>

          <div class="bank-subhead">Predicates (✔/✖)</div>

          <div class="draggable" draggable="true" data-type="fn" data-kind="predicate" data-id="is_even">
            <span>is_even(x)</span>
          </div>
          <div class="draggable" draggable="true" data-type="fn" data-kind="predicate" data-id="is_positive">
            <span>is_positive(x)</span>
          </div>
          <div class="draggable" draggable="true" data-type="fn" data-kind="predicate" data-id="greater_than_2">
            <span>greater_than_2(x)</span>
          </div>

          <div style="height:14px;"></div>

          <div class="bank-subhead">Transforms (→)</div>

          <div class="draggable" draggable="true" data-type="fn" data-kind="transform" data-id="square">
            <span>square(x)</span>
          </div>
          <div class="draggable" draggable="true" data-type="fn" data-kind="transform" data-id="double">
            <span>double(x)</span>
          </div>
          <div class="draggable" draggable="true" data-type="fn" data-kind="transform" data-id="negate">
            <span>negate(x)</span>
          </div>

          <div class="hint" id="rightHint" style="margin-top:12px;"></div>
        </div>
      </section>
    </div>

    <div class="bottom">
      <div class="btnrow">
        <button id="backBtn">◀ Back</button>
        <button id="resetBtn" class="btn-primary">Reset</button>
      </div>
      <div class="btnrow">
        <button id="nextBtn" class="btn-next">Next ▶</button>
      </div>
    </div>
  </div>

  <script src="assets/nav.js"></script>
  <script>
    // ---- Data model ----
    const NUMS = [1,2,3,4,5,6];

    const FUNCTIONS = {
      // predicates
      is_even: { kind: "predicate", label: "is_even", apply: (x) => x % 2 === 0 },
      is_positive: { kind: "predicate", label: "is_positive", apply: (x) => x > 0 },
      greater_than_2: { kind: "predicate", label: "greater_than_2", apply: (x) => x > 2 },
      // transforms
      square: { kind: "transform", label: "square", apply: (x) => x * x },
      double: { kind: "transform", label: "double", apply: (x) => x * 2 },
      negate: { kind: "transform", label: "negate", apply: (x) => -x }
    };

    const PRIMITIVES = {
      filter: {
        label: "filter",
        needsFunction: true,
        accepts: "predicate",
        preview: (fnLabel, numsText) => `nums = ${numsText}\nresult = list(filter(${fnLabel}, nums))\nprint(result)`,
        explain: "filter keeps values that satisfy the predicate (True/False test).",
        eval: (arr, fn) => arr.filter(fn.apply)
      },
      map: {
        label: "map",
        needsFunction: true,
        accepts: "transform",
        preview: (fnLabel, numsText) => `nums = ${numsText}\nresult = list(map(${fnLabel}, nums))\nprint(result)`,
        explain: "map transforms every value independently.",
        eval: (arr, fn) => arr.map(fn.apply)
      },
      sum: {
        label: "sum",
        needsFunction: false,
        accepts: null,
        preview: (_fnLabel, numsText) => `nums = ${numsText}\nresult = sum(nums)\nprint(result)`,
        explain: "sum combines all numeric values into a single result.",
        eval: (arr) => arr.reduce((a,b) => a + b, 0)
      }
    };

    // ---- UI state ----
    let selectedPrimitive = null;
    let selectedFunction = null;

    // ---- DOM ----
    const workspaceEl = document.getElementById("workspace");

    const slotPrimitiveEl = document.getElementById("slotPrimitive");
    const slotFunctionEl = document.getElementById("slotFunction");

    const previewEl = document.getElementById("preview");
    const resultEl = document.getElementById("result");
    const rightHintEl = document.getElementById("rightHint");

    const runBtn = document.getElementById("runBtn");

    const PREVIEW_PROMPT = "# Drag a primitive + (if needed) a function";

    // ---- Terminal typing animation (NEW) ----
    let typingLock = false;
    let pendingPreview = null;
    let lastPreviewText = "";
    let lastRunnable = false;
    let previewTypedForState = false;
    let lastReadySignature = "";


    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({
        "&":"&amp;",
        "<":"&lt;",
        ">":"&gt;",
        '"':"&quot;",
        "'":"&#039;"
      }[c]));
    }

    function numsText(){
      return `[${NUMS.join(", ")}]`;
    }

    function clearWorkspaceStatus(){
      workspaceEl.classList.remove("good","warn","bad");
      rightHintEl.textContent = "";
      rightHintEl.classList.remove("is-warn","is-bad","is-good");
    }

    function setWorkspaceStatus(kind, msg){
      // legacy shim: route all messaging through coach (kept to avoid accidental silent failures)
      const state = kind === "bad" ? "warn" : kind;
      setCoach(state, msg || "");
    }

    function invalidHintHtml(primLabel){
      if (primLabel === "map"){
        return `Map needs a <strong>transform</strong> that changes each element. Try <strong>square</strong>, <strong>double</strong>, or <strong>negate</strong>.`;
      }
      if (primLabel === "filter"){
        return `Filter needs a <strong>predicate</strong> that returns True/False. Try <strong>is_even</strong>, <strong>is_positive</strong>, or <strong>greater_than_2</strong>.`;
      }
      return `That function doesn’t match this primitive.`;
    }

    function pulseDropError(slotEl){
      if (!slotEl) return;
      const cls = "drop-warn";
      slotEl.classList.remove("drop-warn","drop-bad","shake");
      // trigger reflow so the animation can replay
      void slotEl.offsetWidth;
      slotEl.classList.add(cls,"shake");
      window.clearTimeout(pulseDropError._t);
      pulseDropError._t = window.setTimeout(()=>{
        slotEl.classList.remove("shake","drop-warn","drop-bad");
      }, 900);
    }


    function formatOut(out){
      if (Array.isArray(out)) return `[${out.join(", ")}]`;
      return String(out);
    }

    function displayPrimitiveText(pid){
      if (pid === "filter") return "filter( predicate, data )";
      if (pid === "map") return "map( transform, data )";
      if (pid === "sum") return "sum( data )";
      return pid;
    }

    function primitiveHTML(pid){
      if (pid === "filter") {
        return `filter( <span class="conn-token" data-conn="need">predicate</span>, <span class="conn-token" data-conn="data">data</span> )`;
      }
      if (pid === "map") {
        return `map( <span class="conn-token" data-conn="need">transform</span>, <span class="conn-token" data-conn="data">data</span> )`;
      }
      if (pid === "sum") {
        return `sum( <span class="conn-token" data-conn="data">data</span> )`;
      }
      return escapeHtml(pid);
    }

    function fnHTML(fid){
      const f = FUNCTIONS[fid];
      const name = f ? f.label : fid;

      return `<span><span class="conn-token" data-conn="fn">${escapeHtml(name)}</span>(x)</span>`;
    }

    function displayFnText(fid){
      const f = FUNCTIONS[fid];
      return f ? `${f.label}(x)` : fid;
    }

    function setLocked(slotEl, isLocked){
      slotEl.classList.toggle("locked", !!isLocked);
    }

    function isRunnable(){
      if (!selectedPrimitive) return false;
      const prim = PRIMITIVES[selectedPrimitive];
      if (!prim) return false;
      if (!prim.needsFunction) return true;
      if (!selectedFunction) return false;
      const fn = FUNCTIONS[selectedFunction];
      return !!fn && fn.kind === prim.accepts;
    }

    function readySignature(){
      return `${selectedPrimitive || ""}|${selectedFunction || ""}`;
    }

    function setCoach(state, text){
      const el = document.getElementById("coach");
      if (!el) return;

      el.classList.remove("is-good","is-warn","is-bad");
      if (state) el.classList.add(`is-${state}`);

      const t = el.querySelector(".coach-text");
      if (t) t.innerHTML = text;
    }

    function updateRunButton(){
      const runnable = isRunnable();
      runBtn.disabled = !runnable || typingLock;
      runBtn.setAttribute("aria-disabled", String(runBtn.disabled));
      runBtn.classList.toggle("is-enabled", runnable && !typingLock);

      // Only show a “ready” toast when we transition to runnable
      if (runnable && !lastRunnable){      }
      lastRunnable = runnable;
    }

    function clearConnHighlights(){
      document.querySelectorAll('[class*="conn-hl-"]').forEach(el=>{
        el.className = el.className.replace(/\bconn-hl-\d+\b/g, '');
      });
    }

    function applyConnIndex(idx, selector){
      document.querySelectorAll(selector).forEach(el=>{
        el.classList.add(`conn-hl-${idx}`);
      });
    }

    function applyConnHighlights(){
      clearConnHighlights();

      if (!selectedPrimitive) return;

      // Channel 0: data ↔ nums
      applyConnIndex(0, '.conn-token[data-conn="data"]');

      // Channel 1: primitive ↔ function (if compatible)
      if (selectedFunction){
        const prim = PRIMITIVES[selectedPrimitive];
        const fn = FUNCTIONS[selectedFunction];
        if (prim && prim.needsFunction && fn && fn.kind === prim.accepts){
          applyConnIndex(1, '.conn-token[data-conn="need"]');
          applyConnIndex(1, '.conn-token[data-conn="fn"]');
        }
      }
    }

    function setTypingContent(el, text){
      // Insert cursor span without breaking <pre> whitespace
      el.innerHTML = `${escapeHtml(text)}<span class="term-cursor" aria-hidden="true"></span>`;
    }

    async function typeText(el, fullText, opts = {}){
      const speed = typeof opts.speed === "number" ? opts.speed : 10; // ms per char
      const startBlank = opts.startBlank ?? true;

      typingLock = true;
      updateRunButton();

      const text = String(fullText ?? "");
      let i = 0;

      if (startBlank) {
        setTypingContent(el, "");
      } else {
        // If not blank, we still retype from scratch for consistency
        setTypingContent(el, "");
      }

      while (i < text.length){
        // chunk typing for speed (avoid too-slow long blocks)
        const step = Math.min(3, text.length - i);
        i += step;
        setTypingContent(el, text.slice(0, i));
        await new Promise(r => setTimeout(r, speed));
      }

      typingLock = false;
      updateRunButton();
    }

    function queuePreviewTyping(newText){
      if (newText === lastPreviewText) return;
      lastPreviewText = newText;

      if (typingLock){
        pendingPreview = newText;
        return;
      }

      // Fire and forget; when done, flush any pending preview update
      (async ()=>{
        await typeText(previewEl, newText, { speed: 18, startBlank: true });
        if (pendingPreview && pendingPreview !== newText){
          const next = pendingPreview;
          pendingPreview = null;
          queuePreviewTyping(next);
        } else {
          pendingPreview = null;
        }
      })();
    }

    // ---- Rendering ----
    function renderSlots(){
      // Primitive slot
      const primBody = slotPrimitiveEl.querySelector(".slot-body");
      primBody.innerHTML = selectedPrimitive
        ? `<span>${primitiveHTML(selectedPrimitive)}</span>`
        : `<span class="placeholder">Drop a primitive here</span>`;
      setLocked(slotPrimitiveEl, !!selectedPrimitive);

      // Function slot
      const fnBody = slotFunctionEl.querySelector(".slot-body");
      if (!selectedPrimitive){
        fnBody.innerHTML = `<span class="placeholder">Drop a predicate/transform here (if needed)</span>`;
        setLocked(slotFunctionEl, false);
      } else {
        const prim = PRIMITIVES[selectedPrimitive];
        if (!prim.needsFunction){
          fnBody.innerHTML = `<span class="placeholder">(not needed for sum)</span>`;
          setLocked(slotFunctionEl, true);
        } else if (selectedFunction){
          fnBody.innerHTML = fnHTML(selectedFunction);
          setLocked(slotFunctionEl, true);
        } else {
          fnBody.innerHTML = `<span class="placeholder">Drop a ${prim.accepts} here</span>`;
          setLocked(slotFunctionEl, false);
        }
      }

      renderPreviewOnly();
      updateRunButton();
      applyConnHighlights();
    }

    function renderPreviewOnly(){
      clearWorkspaceStatus();

      // Only type when fully runnable
      if (!isRunnable()){
        previewTypedForState = false;
        lastReadySignature = "";
        previewEl.textContent = PREVIEW_PROMPT;   // <- do not change preview at all
        resultEl.textContent = "Output:\n—";
        updateRunButton();
        return;
      }

      // Runnable: type the full code (including nums) once per completed selection
      const prim = PRIMITIVES[selectedPrimitive];
      const numsTxt = numsText();
      const fnLabel = selectedFunction ? FUNCTIONS[selectedFunction].label : null;
      const code = prim.preview(fnLabel, numsTxt); // this should include nums line
      const sig = readySignature();

      if (!previewTypedForState || sig !== lastReadySignature){
        previewTypedForState = true;
        lastReadySignature = sig;
        queuePreviewTyping(code);
      } else {
        previewEl.textContent = code;
      }

      resultEl.textContent = "Output:\n—";
      workspaceEl.classList.add("good");
      updateRunButton();
    }


   async function runAndTypeOutput(){
      if (!isRunnable() || typingLock) return;

      // Freeze the preview without a cursor once Run is pressed
      setTypingContentNoCursor(previewEl, lastPreviewText || previewEl.textContent);

      clearWorkspaceStatus();

      const prim = PRIMITIVES[selectedPrimitive];
      const arr = NUMS.slice();

      let out;
      try {
        out = prim.needsFunction ? prim.eval(arr, FUNCTIONS[selectedFunction]) : prim.eval(arr);
      } catch (e) {
        pulseDropError(workspaceEl);
        setWorkspaceStatus("bad", "Something went wrong evaluating this pipeline.");
        return;
      }

      const outputText = `Output:\n${formatOut(out)}\n\n# ${prim.explain}`;
      await typeText(resultEl, outputText, { speed: 14, startBlank: true });
      workspaceEl.classList.add("good");
    }

    function resetAll(){
      selectedPrimitive = null;
      selectedFunction = null;

      clearWorkspaceStatus();
      resultEl.textContent = "Output:\n—";

      renderSlots();    }

    // ---- Drag & drop ----
    function attachDraggables(){
      document.querySelectorAll(".draggable").forEach(el=>{
        el.addEventListener("dragstart", (e)=>{
          el.classList.add("dragging");
          const payload = {
            type: el.dataset.type,
            id: el.dataset.id,
            kind: el.dataset.kind || null
          };
          e.dataTransfer.setData("text/plain", JSON.stringify(payload));
          e.dataTransfer.effectAllowed = "move";
        });
        el.addEventListener("dragend", ()=>el.classList.remove("dragging"));
      });
    }

    function allowDrop(el){
      el.addEventListener("dragover", (e)=>{
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });
    }

    function handleDropOnSlot(slotKind){
      return (e)=>{
        e.preventDefault();
        const raw = e.dataTransfer.getData("text/plain");
        if (!raw) return;

        let payload;
        try { payload = JSON.parse(raw); } catch { return; }

        if (slotKind === "primitive"){
          if (payload.type !== "primitive"){
            pulseDropError(slotPrimitiveEl);
            setCoach("warn", `This slot needs a <strong>primitive</strong> (filter, map, sum).`);
            return;
          }
          selectedPrimitive = payload.id;
          selectedFunction = null; // avoid stale mismatch
          renderSlots();

          if (selectedPrimitive === "map") setCoach("good", `Nice — you chose <strong>map</strong>. Now add a <strong>transform</strong> function (square, double, negate).`);
          else if (selectedPrimitive === "filter") setCoach("good", `Nice — you chose <strong>filter</strong>. Now add a <strong>predicate</strong> function (is_even, is_positive, greater_than_2).`);
          else if (selectedPrimitive === "sum") setCoach("good", `Nice — you chose <strong>sum</strong>. Run the code in the terminal.`);
          else if (selectedPrimitive === "sum") setCoach("good", `Nice — you chose <strong>sum</strong>. Run the code in the terminal.`);

          return;
        }

        if (slotKind === "function"){
          if (payload.type !== "fn"){
            pulseDropError(slotFunctionEl);
            setCoach("warn", `This slot needs a <strong>function</strong>. Choose the function type requested by the primitive.`);
            return;
          }
          if (!selectedPrimitive){
            pulseDropError(slotFunctionEl);
            setCoach("warn", `Pick a <strong>primitive</strong> first (filter, map, or sum).`);
            return;
          }

          const prim = PRIMITIVES[selectedPrimitive];

          if (!prim.needsFunction){
            pulseDropError(slotFunctionEl);
            setCoach("warn", `<strong>sum</strong> doesn’t take a function — it only needs data.`);
            return;
          }

          const fn = FUNCTIONS[payload.id];
          if (!fn || fn.kind !== prim.accepts){
            pulseDropError(slotFunctionEl);
            setCoach("warn", invalidHintHtml(prim.label));
            return;
          }

          selectedFunction = payload.id;
          renderSlots();

          const fnName = (FUNCTIONS[selectedFunction] && FUNCTIONS[selectedFunction].label) ? FUNCTIONS[selectedFunction].label : selectedFunction;
          if (prim.accepts === "transform") setCoach("good", `Great — <strong>${fnName}</strong> is a <strong>transform</strong>. Run the code in the terminal.`);
          else if (prim.accepts === "predicate") setCoach("good", `Great — <strong>${fnName}</strong> is a <strong>predicate</strong>. Run the code in the terminal.`);
          else setCoach("good", `Great — <strong>${fnName}</strong> fits.`);        }
      };
    }

    // ---- Setup ----
    document.getElementById("resetBtn").addEventListener("click", resetAll);
    runBtn.addEventListener("click", runAndTypeOutput);

    allowDrop(slotPrimitiveEl);
    allowDrop(slotFunctionEl);

    slotPrimitiveEl.addEventListener("drop", handleDropOnSlot("primitive"));
    slotFunctionEl.addEventListener("drop", handleDropOnSlot("function"));

    attachDraggables();

    // Start with a typed prompt (so cursor is visible immediately)
    setTypingContent(previewEl, "# Drag a primitive + (if needed) a function");
    updateRunButton();

    function setTypingContentNoCursor(el, text){
      el.textContent = String(text ?? "");
    }

    // Don't show the "Try..." hint on page 3 (keep node to avoid nulls)
    if (rightHintEl) rightHintEl.style.display = "none";
  </script>
</body>
</html>
