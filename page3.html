<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Compositionality Interactive — Page 3</title>
  <link rel="stylesheet" href="assets/style.css" />
</head>

<body data-page="3" data-prev="page2.html" data-next="page4.html">
  <div class="app">
    <div class="top">
      <h1>Functional primitives</h1>
      <p>
        <strong>Instructions:</strong> Explore how the given primitives work in combination with the functions provided by dragging and dropping elements onto the workspace. The corresponding Python code is generated in the terminal at the bottom of the workspace.
      </p>
    </div>

    <div class="main page3-grid">
      <div class="page3-spacer" aria-hidden="true"></div>

      <!-- Center: hero workspace -->
      <section class="panel page3-hero" aria-label="Interactive workspace">
        <div class="panel-header">
          <div class="title">Workspace</div>
          <div class="pill">Build a pipeline</div>
        </div>

        <!-- PANEL BODY: interactive area ONLY -->
        <div class="panel-body">
          <div class="workspace page3-workspace" id="workspace" aria-label="Workspace surface">
            <!-- Static input array (NEW) -->
            <div class="ws-row">
              <div class="slot locked page3-static" id="staticNums">
                <div class="slot-label">Input</div>
                <div class="slot-body">
                  <span><span class="conn-token" data-conn="data">nums</span> = [1, 2, 3, 4, 5, 6]</span>                
                </div>
              </div>
            </div>

            <div class="ws-row">
              <div class="slot" id="slotPrimitive">
                <div class="slot-label">Primitive</div>
                <div class="slot-body">
                  <span class="placeholder">Drop a primitive here</span>
                </div>
              </div>

              <div class="slot" id="slotFunction">
                <div class="slot-label">Function (optional)</div>
                <div class="slot-body">
                  <span class="placeholder">Drop a predicate/transform here (if needed)</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- PANEL FOOTER: terminal is OUTSIDE panel-body -->
        <div class="panel-footer page3-terminal">
          <div class="terminal" aria-label="Python preview and output">
            <div class="term-title">
              <div class="label">Python (preview &amp; output)</div>

              <!-- REPLACE "simulated" tag with RUN button (NEW) -->
              <button id="runBtn" class="term-run" disabled aria-disabled="true">Run</button>
            </div>

            <!-- Typed preview (NEW: typing animation + cursor) -->
            <pre id="preview" class="term-typing" aria-live="polite"></pre>
            <div class="term-sep"></div>

            <!-- Output only types when Run pressed -->
            <pre id="result" class="muted term-typing">Output:
—</pre>

            <pre id="hint" class="muted" style="margin-top:10px; display:none;"></pre>
          </div>
        </div>
      </section>

      <!-- Right: toolbox -->
      <section class="panel page3-bank" aria-label="Toolbox">
        <div class="panel-header">
          <div class="title">Toolbox</div>
          <div class="pill">Drag items</div>
        </div>

        <div class="panel-body">
          <!-- Arrays section REMOVED -->

          <div class="group-title">Primitives</div>

          <div class="draggable" draggable="true" data-type="primitive" data-id="sum">
            <span>sum( data )</span>
          </div>         
          <div class="draggable" draggable="true" data-type="primitive" data-id="map">
            <span>map( transform, data )</span>
          </div>
          <div class="draggable" draggable="true" data-type="primitive" data-id="filter">
            <span>filter( predicate, data )</span>
          </div>

          <div style="height:14px;"></div>

          <div class="group-title">Functions</div>

          <div class="bank-subhead">Predicates (✔/✖)</div>

          <div class="draggable" draggable="true" data-type="fn" data-kind="predicate" data-id="is_even">
            <span>is_even(x)</span>
          </div>
          <div class="draggable" draggable="true" data-type="fn" data-kind="predicate" data-id="is_positive">
            <span>is_positive(x)</span>
          </div>
          <div class="draggable" draggable="true" data-type="fn" data-kind="predicate" data-id="greater_than_2">
            <span>greater_than_2(x)</span>
          </div>

          <div style="height:14px;"></div>

          <div class="bank-subhead">Transforms (→)</div>

          <div class="draggable" draggable="true" data-type="fn" data-kind="transform" data-id="square">
            <span>square(x)</span>
          </div>
          <div class="draggable" draggable="true" data-type="fn" data-kind="transform" data-id="double">
            <span>double(x)</span>
          </div>
          <div class="draggable" draggable="true" data-type="fn" data-kind="transform" data-id="negate">
            <span>negate(x)</span>
          </div>

          <div class="hint" id="rightHint" style="margin-top:12px;"></div>
        </div>
      </section>
    </div>

    <div class="bottom">
      <div class="btnrow">
        <button id="backBtn">◀ Back</button>
        <button id="resetBtn" class="btn-primary">Reset</button>
      </div>
      <div class="btnrow">
        <button id="nextBtn" class="btn-next">Next ▶</button>
      </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>
  </div>

  <script src="assets/nav.js"></script>
  <script>
    // ---- Data model ----
    const NUMS = [1,2,3,4,5,6];

    const FUNCTIONS = {
      // predicates
      is_even: { kind: "predicate", label: "is_even", apply: (x) => x % 2 === 0 },
      is_positive: { kind: "predicate", label: "is_positive", apply: (x) => x > 0 },
      greater_than_2: { kind: "predicate", label: "greater_than_2", apply: (x) => x > 2 },
      // transforms
      square: { kind: "transform", label: "square", apply: (x) => x * x },
      double: { kind: "transform", label: "double", apply: (x) => x * 2 },
      negate: { kind: "transform", label: "negate", apply: (x) => -x }
    };

    const PRIMITIVES = {
      filter: {
        label: "filter",
        needsFunction: true,
        accepts: "predicate",
        preview: (fnLabel, numsText) => `nums = ${numsText}\nresult = list(filter(${fnLabel}, nums))\nprint(result)`,
        explain: "filter keeps values that satisfy the predicate (True/False test).",
        eval: (arr, fn) => arr.filter(fn.apply)
      },
      map: {
        label: "map",
        needsFunction: true,
        accepts: "transform",
        preview: (fnLabel, numsText) => `nums = ${numsText}\nresult = list(map(${fnLabel}, nums))\nprint(result)`,
        explain: "map transforms every value independently.",
        eval: (arr, fn) => arr.map(fn.apply)
      },
      sum: {
        label: "sum",
        needsFunction: false,
        accepts: null,
        preview: (_fnLabel, numsText) => `nums = ${numsText}\nresult = sum(nums)\nprint(result)`,
        explain: "sum combines all numeric values into a single result.",
        eval: (arr) => arr.reduce((a,b) => a + b, 0)
      }
    };

    // ---- UI state ----
    let selectedPrimitive = null;
    let selectedFunction = null;

    // ---- DOM ----
    const toastEl = document.getElementById("toast");
    const workspaceEl = document.getElementById("workspace");

    const slotPrimitiveEl = document.getElementById("slotPrimitive");
    const slotFunctionEl = document.getElementById("slotFunction");

    const previewEl = document.getElementById("preview");
    const resultEl = document.getElementById("result");
    const hintEl = document.getElementById("hint");
    const rightHintEl = document.getElementById("rightHint");

    const runBtn = document.getElementById("runBtn");

    const PREVIEW_PROMPT = "# Drag a primitive + (if needed) a function";

    // ---- Terminal typing animation (NEW) ----
    let typingLock = false;
    let pendingPreview = null;
    let lastPreviewText = "";
    let lastRunnable = false;
    let previewTypedForState = false;
    let lastReadySignature = "";


    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({
        "&":"&amp;",
        "<":"&lt;",
        ">":"&gt;",
        '"':"&quot;",
        "'":"&#039;"
      }[c]));
    }

    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      window.clearTimeout(showToast._t);
      showToast._t = window.setTimeout(()=>toastEl.classList.remove("show"), 2000);
    }

    function numsText(){
      return `[${NUMS.join(", ")}]`;
    }

    function clearWorkspaceStatus(){
      workspaceEl.classList.remove("good","warn","bad");
      hintEl.style.display = "none";
      hintEl.textContent = "";
    }

    function setWorkspaceStatus(kind, msg){
      workspaceEl.classList.remove("good","warn","bad");
      workspaceEl.classList.add(kind);
      hintEl.style.display = "block";
      hintEl.textContent = msg;
    }

    function invalidHint(primLabel){
      if (primLabel === "filter") return "filter needs a function that returns True/False (a predicate).";
      if (primLabel === "map") return "map needs a function that returns a value (a transform).";
      return "That function doesn't fit this primitive.";
    }

    function formatOut(out){
      if (Array.isArray(out)) return `[${out.join(", ")}]`;
      return String(out);
    }

    function displayPrimitiveText(pid){
      if (pid === "filter") return "filter( predicate, data )";
      if (pid === "map") return "map( transform, data )";
      if (pid === "sum") return "sum( data )";
      return pid;
    }

    function primitiveHTML(pid){
      if (pid === "filter") {
        return `filter( <span class="conn-token" data-conn="need">predicate</span>, <span class="conn-token" data-conn="data">data</span> )`;
      }
      if (pid === "map") {
        return `map( <span class="conn-token" data-conn="need">transform</span>, <span class="conn-token" data-conn="data">data</span> )`;
      }
      if (pid === "sum") {
        return `sum( <span class="conn-token" data-conn="data">data</span> )`;
      }
      return escapeHtml(pid);
    }

    function fnHTML(fid){
      const f = FUNCTIONS[fid];
      const name = f ? f.label : fid;

      return `<span><span class="conn-token" data-conn="fn">${escapeHtml(name)}</span>(x)</span>`;
    }

    function displayFnText(fid){
      const f = FUNCTIONS[fid];
      return f ? `${f.label}(x)` : fid;
    }

    function setLocked(slotEl, isLocked){
      slotEl.classList.toggle("locked", !!isLocked);
    }

    function isRunnable(){
      if (!selectedPrimitive) return false;
      const prim = PRIMITIVES[selectedPrimitive];
      if (!prim) return false;
      if (!prim.needsFunction) return true;
      if (!selectedFunction) return false;
      const fn = FUNCTIONS[selectedFunction];
      return !!fn && fn.kind === prim.accepts;
    }

    function readySignature(){
      return `${selectedPrimitive || ""}|${selectedFunction || ""}`;
    }

    function updateRunButton(){
      const runnable = isRunnable();
      runBtn.disabled = !runnable || typingLock;
      runBtn.setAttribute("aria-disabled", String(runBtn.disabled));
      runBtn.classList.toggle("is-enabled", runnable && !typingLock);

      // Only show a “ready” toast when we transition to runnable
      if (runnable && !lastRunnable){
        showToast("Ready — press Run.");
      }
      lastRunnable = runnable;
    }

    function clearConnHighlights(){
      document.querySelectorAll('[class*="conn-hl-"]').forEach(el=>{
        el.className = el.className.replace(/\bconn-hl-\d+\b/g, '');
      });
    }

    function applyConnIndex(idx, selector){
      document.querySelectorAll(selector).forEach(el=>{
        el.classList.add(`conn-hl-${idx}`);
      });
    }

    function applyConnHighlights(){
      clearConnHighlights();

      if (!selectedPrimitive) return;

      // Channel 0: data ↔ nums
      applyConnIndex(0, '.conn-token[data-conn="data"]');

      // Channel 1: primitive ↔ function (if compatible)
      if (selectedFunction){
        const prim = PRIMITIVES[selectedPrimitive];
        const fn = FUNCTIONS[selectedFunction];
        if (prim && prim.needsFunction && fn && fn.kind === prim.accepts){
          applyConnIndex(1, '.conn-token[data-conn="need"]');
          applyConnIndex(1, '.conn-token[data-conn="fn"]');
        }
      }
    }

    function setTypingContent(el, text){
      // Insert cursor span without breaking <pre> whitespace
      el.innerHTML = `${escapeHtml(text)}<span class="term-cursor" aria-hidden="true"></span>`;
    }

    async function typeText(el, fullText, opts = {}){
      const speed = typeof opts.speed === "number" ? opts.speed : 10; // ms per char
      const startBlank = opts.startBlank ?? true;

      typingLock = true;
      updateRunButton();

      const text = String(fullText ?? "");
      let i = 0;

      if (startBlank) {
        setTypingContent(el, "");
      } else {
        // If not blank, we still retype from scratch for consistency
        setTypingContent(el, "");
      }

      while (i < text.length){
        // chunk typing for speed (avoid too-slow long blocks)
        const step = Math.min(3, text.length - i);
        i += step;
        setTypingContent(el, text.slice(0, i));
        await new Promise(r => setTimeout(r, speed));
      }

      typingLock = false;
      updateRunButton();
    }

    function queuePreviewTyping(newText){
      if (newText === lastPreviewText) return;
      lastPreviewText = newText;

      if (typingLock){
        pendingPreview = newText;
        return;
      }

      // Fire and forget; when done, flush any pending preview update
      (async ()=>{
        await typeText(previewEl, newText, { speed: 18, startBlank: true });
        if (pendingPreview && pendingPreview !== newText){
          const next = pendingPreview;
          pendingPreview = null;
          queuePreviewTyping(next);
        } else {
          pendingPreview = null;
        }
      })();
    }

    // ---- Rendering ----
    function renderSlots(){
      // Primitive slot
      const primBody = slotPrimitiveEl.querySelector(".slot-body");
      primBody.innerHTML = selectedPrimitive
        ? `<span>${primitiveHTML(selectedPrimitive)}</span>`
        : `<span class="placeholder">Drop a primitive here</span>`;
      setLocked(slotPrimitiveEl, !!selectedPrimitive);

      // Function slot
      const fnBody = slotFunctionEl.querySelector(".slot-body");
      if (!selectedPrimitive){
        fnBody.innerHTML = `<span class="placeholder">Drop a predicate/transform here (if needed)</span>`;
        setLocked(slotFunctionEl, false);
      } else {
        const prim = PRIMITIVES[selectedPrimitive];
        if (!prim.needsFunction){
          fnBody.innerHTML = `<span class="placeholder">(not needed for sum)</span>`;
          setLocked(slotFunctionEl, true);
        } else if (selectedFunction){
          fnBody.innerHTML = fnHTML(selectedFunction);
          setLocked(slotFunctionEl, true);
        } else {
          fnBody.innerHTML = `<span class="placeholder">Drop a ${prim.accepts} here</span>`;
          setLocked(slotFunctionEl, false);
        }
      }

      renderPreviewOnly();
      updateRunButton();
      applyConnHighlights();
    }

    function renderPreviewOnly(){
      clearWorkspaceStatus();

      // Only type when fully runnable
      if (!isRunnable()){
        previewTypedForState = false;
        lastReadySignature = "";
        previewEl.textContent = PREVIEW_PROMPT;   // <- do not change preview at all
        resultEl.textContent = "Output:\n—";
        updateRunButton();
        return;
      }

      // Runnable: type the full code (including nums) once per completed selection
      const prim = PRIMITIVES[selectedPrimitive];
      const numsTxt = numsText();
      const fnLabel = selectedFunction ? FUNCTIONS[selectedFunction].label : null;
      const code = prim.preview(fnLabel, numsTxt); // this should include nums line
      const sig = readySignature();

      if (!previewTypedForState || sig !== lastReadySignature){
        previewTypedForState = true;
        lastReadySignature = sig;
        queuePreviewTyping(code);
      } else {
        previewEl.textContent = code;
      }

      resultEl.textContent = "Output:\n—";
      workspaceEl.classList.add("good");
      updateRunButton();
    }


   async function runAndTypeOutput(){
      if (!isRunnable() || typingLock) return;

      // Freeze the preview without a cursor once Run is pressed
      setTypingContentNoCursor(previewEl, lastPreviewText || previewEl.textContent);

      clearWorkspaceStatus();

      const prim = PRIMITIVES[selectedPrimitive];
      const arr = NUMS.slice();

      let out;
      try {
        out = prim.needsFunction ? prim.eval(arr, FUNCTIONS[selectedFunction]) : prim.eval(arr);
      } catch (e) {
        setWorkspaceStatus("bad", "Something went wrong evaluating this pipeline.");
        await typeText(resultEl, "Output:\n—", { speed: 14, startBlank: true });
        return;
      }

      const outputText = `Output:\n${formatOut(out)}\n\n# ${prim.explain}`;
      await typeText(resultEl, outputText, { speed: 14, startBlank: true });
      workspaceEl.classList.add("good");
    }

    function resetAll(){
      selectedPrimitive = null;
      selectedFunction = null;

      clearWorkspaceStatus();
      resultEl.textContent = "Output:\n—";

      renderSlots();
      showToast("Reset.");
    }

    // ---- Drag & drop ----
    function attachDraggables(){
      document.querySelectorAll(".draggable").forEach(el=>{
        el.addEventListener("dragstart", (e)=>{
          el.classList.add("dragging");
          const payload = {
            type: el.dataset.type,
            id: el.dataset.id,
            kind: el.dataset.kind || null
          };
          e.dataTransfer.setData("text/plain", JSON.stringify(payload));
          e.dataTransfer.effectAllowed = "move";
        });
        el.addEventListener("dragend", ()=>el.classList.remove("dragging"));
      });
    }

    function allowDrop(el){
      el.addEventListener("dragover", (e)=>{
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });
    }

    function handleDropOnSlot(slotKind){
      return (e)=>{
        e.preventDefault();
        const raw = e.dataTransfer.getData("text/plain");
        if (!raw) return;

        let payload;
        try { payload = JSON.parse(raw); } catch { return; }

        if (slotKind === "primitive"){
          if (payload.type !== "primitive"){
            showToast("Drop a primitive here.");
            return;
          }
          selectedPrimitive = payload.id;
          selectedFunction = null; // avoid stale mismatch
          renderSlots();
          showToast("Primitive set.");
          return;
        }

        if (slotKind === "function"){
          if (payload.type !== "fn"){
            showToast("Drop a function here.");
            return;
          }
          if (!selectedPrimitive){
            setWorkspaceStatus("warn", "Pick a primitive first.");
            showToast("Choose a primitive first.");
            return;
          }

          const prim = PRIMITIVES[selectedPrimitive];

          if (!prim.needsFunction){
            setWorkspaceStatus("warn", "sum doesn’t take a function.");
            showToast("sum doesn’t take a function.");
            return;
          }

          const fn = FUNCTIONS[payload.id];
          if (!fn || fn.kind !== prim.accepts){
            setWorkspaceStatus("warn", invalidHint(prim.label));
            showToast("That function doesn’t fit.");
            return;
          }

          selectedFunction = payload.id;
          renderSlots();
          showToast("Function set.");
        }
      };
    }

    // ---- Setup ----
    document.getElementById("resetBtn").addEventListener("click", resetAll);
    runBtn.addEventListener("click", runAndTypeOutput);

    allowDrop(slotPrimitiveEl);
    allowDrop(slotFunctionEl);

    slotPrimitiveEl.addEventListener("drop", handleDropOnSlot("primitive"));
    slotFunctionEl.addEventListener("drop", handleDropOnSlot("function"));

    attachDraggables();

    // Start with a typed prompt (so cursor is visible immediately)
    setTypingContent(previewEl, "# Drag a primitive + (if needed) a function");
    updateRunButton();

    function setTypingContentNoCursor(el, text){
      el.textContent = String(text ?? "");
    }

    // Don't show the "Try..." hint on page 3 (keep node to avoid nulls)
    if (rightHintEl) rightHintEl.style.display = "none";
  </script>
</body>
</html>
